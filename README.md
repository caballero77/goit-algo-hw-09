# Порівняння жадібного алгоритму та алгоритму динамічного програмування

Обидва алгоритми мають свої переваги та недоліки, які стають очевидними при аналізі їх часової складності та поведінки з великими сумами.

## Жадібний алгоритм

- **Часова складність**: \(O(n)\), де \(n\) — кількість доступних номіналів монет.
- **Продуктивність**: Жадібний алгоритм працює дуже швидко, оскільки він просто проходить по списку монет один раз. Він підходить для ситуацій, де монетний набір забезпечує оптимальне рішення (як у випадку з класичними монетами у 50, 25, 10, 5, 2, 1).

- **Мінуси**: Цей алгоритм може бути неефективним або навіть неправильним, якщо набір монет не забезпечує оптимального рішення жадібним методом. Наприклад, якщо у нас є монети номіналами 4, 3, 1, і потрібно видати суму 6, жадібний алгоритм вибере 4 + 1 + 1, тоді як оптимальне рішення — 3 + 3.

- **Переваги**: Жадібний алгоритм чудово справляється з великими сумами завдяки своїй низькій складності та швидкості виконання. Для великих сум його продуктивність залишається стабільною.

## Алгоритм динамічного програмування

- **Часова складність**: \(O(n \times m)\), де \(n\) — кількість номіналів монет, а \(m\) — сума, яку потрібно видати.
- **Продуктивність**: Алгоритм динамічного програмування забезпечує оптимальне рішення для будь-якого набору монет, мінімізуючи кількість використовуваних монет. Він підходить для ситуацій, де необхідно знайти оптимальне рішення для складних або нестандартних наборів монет.

- **Мінуси**: Основний недолік цього алгоритму — його часова складність. Для великих сум алгоритм може бути повільним через необхідність обчислень для всіх проміжних значень від 1 до шуканої суми.

- **Переваги**: Гарантовано знаходить мінімальну кількість монет для будь-якої суми та набору монет, що робить його універсальним.

## Висновок

Жадібний алгоритм є більш ефективним для стандартних наборів монет і великих сум завдяки його простоті та низькій часовій складності. Він швидкий і працює за лінійний час, що робить його підходящим для використання в реальних касових системах.

З іншого боку, алгоритм динамічного програмування підходить для будь-яких наборів монет, особливо коли жадібний алгоритм не може гарантувати оптимальне рішення. Проте, для великих сум його продуктивність падає через квадратичну складність, що робить його менш практичним для використання в реальному часі, коли потрібно видавати великі суми.
